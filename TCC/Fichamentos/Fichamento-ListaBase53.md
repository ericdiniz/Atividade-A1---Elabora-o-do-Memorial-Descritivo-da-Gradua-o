# On the Efficiency of Test Suite based Program Repair: A Systematic Assessment of 16 Automated Repair Systems for Java Programs

LIU, Kui et al. On the efficiency of test suite based program repair: A systematic assessment of 16 automated repair systems for java programs. In: Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering. 2020. p. 615-627.

## 1. Fichamento de Conteúdo

A automação da reparação de programas (*Automated Program Repair – APR*) baseada em testes tem se consolidado como um campo promissor da engenharia de software, visando reduzir o esforço manual na correção de *bugs*. Tradicionalmente, a avaliação dessas ferramentas enfatiza a efetividade (quantos *bugs* podem ser corrigidos), mas pouco se discute sobre sua eficiência, ou seja, quantos candidatos a *patch* precisam ser gerados antes de se encontrar uma solução válida. Este artigo aborda essa lacuna, propondo o uso do Número de Candidatos a *Patch – NPC* como métrica intrínseca, em contraste com o tempo de execução, considerado instável e dependente de variáveis externas. A metodologia consistiu em um estudo empírico de larga escala, avaliando 16 sistemas *APR* de código aberto para programas Java. Os autores selecionaram essas ferramentas com base em critérios de disponibilidade, executabilidade, configurabilidade e independência. O *benchmark* utilizado foi o *Defects4J*, contendo 395 *bugs* reais distribuídos em seis projetos Java. Todos os sistemas foram configurados de forma padronizada com a ferramenta *GZoltar* para localização de falhas, assegurando comparabilidade. O processo de validação dos *patches* considerou tanto plausibilidade (passar em todos os testes) quanto correção (semelhança semântica com o *patch* do desenvolvedor, avaliada por regras explícitas). Foi definido um limite máximo de 10.000 tentativas de reparo por *bug*. Os resultados responderam a três questões de pesquisa: (i) reparabilidade ao longo do tempo (RQ1); (ii) eficiência na geração de *patches* (RQ2); (iii) impacto do ruído na localização de falhas (RQ3). Constatou-se que a eficiência ainda não é valorizada como objetivo central: ferramentas *template-based* (como *TBar* e *kPAR*) são eficazes em corrigir muitos *bugs*, mas tendem a ser as menos eficientes, gerando milhares de candidatos irrelevantes. Por outro lado, abordagens baseadas em restrições, como o *ACS*, mostraram maior precisão, reduzindo o desperdício de recursos. O estudo também evidenciou que o ruído na localização de falhas degrada significativamente a eficiência, especialmente em sistemas *template-based*. Em contrapartida, ferramentas como *SimFix* se destacaram por não gerar *patches* sem sentido, ainda que em grande quantidade. Assim, o trabalho reforça que a adoção prática da *APR* depende não apenas da quantidade de *bugs* corrigidos, mas também da eficiência dos processos de geração e validação de *patches*. O uso do NPC como métrica traz uma contribuição metodológica relevante, ao permitir comparações mais confiáveis entre ferramentas e identificar estratégias que podem tornar a *APR* mais aplicável no contexto real de desenvolvimento.


## 2. Fichamento Bibliográfico

* Automated Program Repair (APR): Campo de pesquisa proeminente em engenharia de software que visa a correção automática de *bugs* em programas, frequentemente utilizando suítes de testes como especificações parciais para validar os *patches* gerados.
* Eficiência da Geração de Patches: Uma propriedade chave para a praticidade da reparação automática de programas, avaliada pelo número de tentativas que o sistema de reparo faz antes de encontrar um *patch* válido. Esta métrica é considerada intrínseca à abordagem de reparo, ao contrário do tempo de execução, que é instável e dependente de variáveis externas.
* Patch Plausível: Um *patch* candidato que, ao ser aplicado, faz com que o programa modificado passe todos os casos de teste na suíte de testes (tanto os que passavam quanto os que falhavam na versão *buggy*). Embora passe os testes, pode ser semanticamente incorreto (overfitting).
* Patch Correto: Um *patch* plausível que é considerado semanticamente similar ao *patch* fornecido pelo desenvolvedor no *benchmark*. A determinação de "correto" é frequentemente um esforço manual, mas o estudo propõe regras explícitas para essa avaliação.
* Número de Candidatos a Patch (NPC): A métrica de eficiência central do estudo, que quantifica o total de candidatos a *patch* (incluindo *nonsensical*, *in-plausible* e *valid*) gerados por uma ferramenta APR até a identificação do primeiro *patch* plausível.
* Ruído na Localização de Falhas: Refere-se à imprecisão nas informações de localização de falhas fornecidas às ferramentas APR, onde posições de código suspeitas podem ser falsos positivos. Este ruído tem um impacto significativo na eficiência e na capacidade de reparo das ferramentas.

## 3. Fichamento de Citações

* "Although the literature regularly sets new records on the number of benchmark bugs that can be fixed, several studies increasingly raise concerns about the limitations and biases of state-of-the-art approaches."
* "Nevertheless, there is little work addressing the efficiency of patch generation, with regard to the practicality of program repair."
* "We postulate that the efficiency of test-based program repair should be assessed along with the following question: how many attempts does the repair system make before catching a valid patch?"
* "Test suite based program repair systems commonly implement a three-step pipeline as illustrated in Figure 2: fault localization, which produces a ranked list of suspicious code locations that should be modified to fix the bug; patch generation, which implements the change operators that are applied on the buggy code locations; and patch validation, which executes the test cases to check that the patched program meets the behaviour (approximately) specified by the test suite."
* "Template-based repair systems are generally inefficient as they produce too many patch candidates. However, when the templates are mined from clean datasets or are specialized to specific bugs, efficiency can be substantially improved."
* "Fault localization is an important step in a repair pipeline. Its false positives, however, have a significant impact on both repairability and repair efficiency."
